<h2>Type casting</h2>
<div class="step-text">
<p>Suppose you need to assign a value of one type to a variable of another type. To do that, your program needs to cast the source type to the <a class="theory-lookup" href="/learn/step/12806" rel="noopener noreferrer nofollow" target="_blank" title="The target type in Java refers to the data type that is expected or required in a specific context, such as the left-hand side of an assignment or the method call argument. | It can be explicitly specified or automatically inferred based on the context. The target type determines the set of possible values and operations that can be used in that context. Java supports various target types, including primitive types, reference types, and user-defined types, which can be used to declare variables, define methods, and create objects.">target type</a>. Java provides two kinds of casting for <a class="theory-lookup" href="/learn/step/3532" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a primitive type is one of eight built-in data types provided by the language. | They are represented by keywords and are not objects, unlike reference types. Primitive types are divided into groups based on their meaning, and each group operates similarly but has different sizes and ranges of values. The most commonly used primitive type is `int`, which represents an integer number. Java also provides several types for integer and fractional numbers, which are often used in arithmetic expressions.">primitive types</a>:<strong> implicit</strong> and <strong>explicit</strong>. The first one is performed automatically by the Java compiler when it is possible, while the second one can only be done by a programmer.</p><h5 id="implicit-casting">Implicit casting</h5><p>The compiler automatically performs <strong><a class="theory-lookup" href="/learn/step/3525" rel="noopener noreferrer nofollow" target="_blank" title="Implicit casting, also known as automatic casting, is a process in Java where the compiler automatically converts a value of one type to another type, without requiring any explicit instructions from the programmer. | This occurs when the target type is wider than the source type, meaning that the target type can accommodate all possible values of the source type. Examples of implicit casting include converting a smaller integer type to a larger integer type, or a floating-point type to a larger floating-point type.">implicit casting</a></strong> when the target type is wider than the source type. The picture below illustrates the direction of this casting. Any value of a given type can be assigned to the one on the right implicitly or below in the case of <code class="language-java">char</code>.</p><p style="text-align: center;"><picture><img alt="implicit casting" height="217" src="https://ucarecdn.com/c00fb67e-ba08-44a2-ad8b-0ffbdfe8d642/" width="1461"/></picture></p><p style="text-align: center;"><br/><br/><strong>The</strong> <strong>direction</strong> <strong>of</strong> <strong>implicit</strong> <strong>primitive</strong> <strong>type</strong> <strong>castings</strong></p><p>Normally, there is no loss of information when the target type is wider than the source type, for example, when we cast <code class="language-java">int</code> to <code class="language-java">long</code>. But it is not possible to automatically cast in the backward order (e.g. from <code class="language-java">long</code> to <code class="language-java">int</code> or from <code class="language-java">double</code> to <code class="language-java">float</code>).</p><p> </p><p></p><div class="alert alert-primary"><p>Note that there is no <code class="language-java">boolean</code> type on the picture above because it is impossible to cast this type to any other and vice versa.</p></div><p></p><p> </p><p>Here are several examples of implicit castings:</p><ul><li><p>from <code class="language-java">int</code> to <code class="language-java">long</code>:</p></li></ul><pre><code class="language-java">int num = 100;
long bigNum = num; // 100L
</code></pre><ul><li><p>from <code class="language-java">long</code> to <code class="language-java">double</code>:</p></li></ul><pre><code class="language-java">long bigNum = 100_000_000L;
double bigFraction = bigNum; // 100000000.0
</code></pre><ul><li><p> from <code class="language-java">short</code> to <code class="language-java">int</code>:</p></li></ul><pre><code class="language-java">short shortNum = 100;
int num = shortNum; // 100</code></pre><ul><li><p> from <code class="language-java">char</code> to <code class="language-java">int</code>:</p></li></ul><pre><code class="language-java">char ch = '?';
int code = ch; // 63</code></pre><p>In some cases, implicit <a class="theory-lookup" href="/learn/step/3525" rel="noopener noreferrer nofollow" target="_blank" title="In Java, type casting is the process of converting a value of one data type to another. | There are two types of casting: implicit and explicit. Implicit casting, also known as widening, occurs automatically when the target type is larger than the source type. Explicit casting, also known as narrowing, is done manually by the programmer and can result in type overflow if the target type cannot store the full value of the source type. It is important to note that casting between primitive types and the Object type is not possible in Java.">type casting</a> may result in some information loss. When we convert an <code class="language-java">int</code> to <code class="language-java">float</code>, or a <code class="language-java">long</code> to <code class="language-java">float</code> or to <code class="language-java">double</code>, we may lose some less significant bits of the value, which will result in a loss of <a class="theory-lookup" href="/learn/step/13511" rel="noopener noreferrer nofollow" target="_blank" title="Precision in Java refers to the exactness or the number of significant digits that a number can represent. | In Java, there are two basic types used to represent fractional numbers, float and double, which are called floating-point types. These types can only represent a limited number of significant decimal digits, with float supporting 6-7 digits and double supporting 15-16 digits.">precision</a>. However, the result of this conversion will be a correctly rounded version of the integer value, which will be in the overall <a class="theory-lookup" href="/learn/step/18021" rel="noopener noreferrer nofollow" target="_blank" title="In Java, range refers to a sequence of values within a specific range, often used to represent a continuous set of data. | It can be implemented using various data structures such as arrays, lists, or custom classes. A range can be accessed, modified, and iterated over, making it a versatile tool for working with collections of data. The iterator design pattern can be used to provide a universal interface for accessing elements of any collection contained in a Java class, including ranges.">range</a> of the target type. To understand that, check out the example:</p><pre><code class="language-java">long bigLong =  1_200_000_002L;
float bigFloat = bigLong; // 1.2E9 (= 1_200_000_000)</code></pre><p>When we convert a <code class="language-java">char</code> to an <code class="language-java">int</code> in Java, we actually get the ASCII value for a given <a class="theory-lookup" href="/learn/step/3522" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a character is a single symbol, denoted with a single quote, that can represent a letter, digit, whitespace, or other symbols. | It is actually an integer type that stores the Unicode integer value of each character, which is why character literals can be used as integers if needed. The numeric value of a character can be found in a special table online, and since Java 7, underscores can be used between digits to increase the readability of numeric literals.">character</a>. The ASCII value is an integer representation of English alphabet letters (both uppercase and lowercase), digits, and other symbols. <a href="https://ascii.cl/" rel="noopener noreferrer nofollow" target="_blank">Here</a> you can find some of the standard symbols in ASCII.</p><pre><code class="language-java">char character = 'a';
char upperCase = 'A';

int ascii1 = character; // this is 97
int ascii2 = upperCase; // this is 65</code></pre><p> </p><p></p><div class="alert alert-primary"><p>Strictly speaking, Java uses Unicode Character Representations (UTF-16), which is a superset of ASCII and includes a by far larger set of symbols. However, the numbers 0â€“127 have the same values in ASCII and Unicode.</p></div><p></p><p> </p><p>As you can see, implicit casting works absolutely transparently.</p><h5 id="explicit-casting">Explicit casting</h5><p>The considered <strong>implicit casting</strong> does not work when the target type is narrower than the source type. But programmers can apply <strong><a class="theory-lookup" href="/learn/step/3525" rel="noopener noreferrer nofollow" target="_blank" title="Explicit casting in Java is a process where a programmer manually converts a value from one data type to another, even if the target type is narrower than the source type. | This can result in loss of information about the overall magnitude of a numeric value and may also lead to loss of precision. To perform explicit casting, the target type is written in parentheses before the source. It's important to note that not all castings are possible, such as casting from a wider type to a narrower type like int to byte, which is not allowed in Java.">explicit casting</a></strong> to a source type to get another type they want. It may lose information about the overall magnitude of a numeric value and may also lose precision.</p><p>To perform explicit casting, a programmer must write the target type in parentheses before the source.</p><pre><code class="language-java">(targetType) source</code></pre><p>Any possible casting not presented in the picture above needs such an approach, for example <code class="language-java">double</code> to <code class="language-java">int</code>, and <code class="language-java">long</code> to <code class="language-java">char</code>.</p><p>Examples:</p><pre><code class="language-java">double d = 2.00003;

// it loses the fractional part
long l =  (long) d; // 2

// requires explicit casting because long is wider than int
int i = (int) l; // 2 

// requires explicit casting because the result is long (indicated by L)
int val = (int) (3 + 2L); // 5

// casting from a long literal to char
char ch = (char) 55L; // '7'</code></pre><p>However, the explicit casting may truncate the value because <code class="language-java">long</code> and <code class="language-java">double</code> can store a much larger number than <code class="language-java">int</code>.</p><pre><code class="language-java">long bigNum = 100_000_000_000_000L;
int n = (int) bigNum; // 276447232</code></pre><p>Oops! The value has been truncated. This problem is known as <strong><a class="theory-lookup" href="/learn/step/3525" rel="noopener noreferrer nofollow" target="_blank" title="In Java, type overflow is a situation that occurs when a value is too large to be stored in a variable of a particular data type, causing it to overflow and wrap around to a smaller value. | This can happen with integer types when the value exceeds their maximum positive or negative range, or with floating-point types when the value exceeds their maximum precision. Type overflow can lead to unexpected results and should be avoided by using appropriate data types and performing range checks.">type overflow</a></strong>. The same problem may occur when casting <code class="language-java">int</code> to <code class="language-java">short</code> or <code class="language-java">byte</code>. Let's see what happens exactly. </p><p>As you remember, in Java <code class="language-java">long</code> is a 64-<a class="theory-lookup" href="/learn/step/3515" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a bit is the smallest unit of data storage, representing either a 0 or 1. | It is used to build larger data types, such as bytes, integers, and booleans.">bit</a> <a class="theory-lookup" href="/learn/step/3494" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a number is a data type that represents a numeric value. | It can be an integer, which is a whole number, or a floating-point number, which is a number with a decimal point. Java provides several integer types, including `byte`, `short`, `int`, and `long`, with `int` being the most commonly used. For floating-point numbers, Java provides `float` and `double` types, with `double` being the most commonly used.">number</a>, while <code class="language-java">int</code> is 32-bit. When converting <code class="language-java">long</code> to <code class="language-java">int</code> the program just takes the last 32 bits to represent the new number. If the <code class="language-java">long</code> contains a number less than or equal to <code class="language-java">Integer.MAX_VALUE</code> you can convert it by casting without losing information. Otherwise, the result will be quite meaningless, although determined. That is why you shouldn't perform casting from a larger type to a smaller type unless you are absolutely sure that it is necessary and that truncation will not interfere with your program.</p><p>Explicit casting also works when implicit casting is enough.</p><pre><code class="language-java">int num = 10;
long bigNum = (long) num; // redundant casting</code></pre><p>But this is redundant and should not be used to avoid unnecessary constructs in your code.</p><p> </p><p></p><div class="alert alert-primary"><p><strong>Note,</strong> that despite the power of explicit casting, it is still impossible to cast something to and from the <code class="language-java">boolean</code> type.</p></div><p></p><p> </p><h5 id="conclusion">Conclusion</h5><p>If you want to cast a narrower type to a wider type, you do not need to write anything, the Java compiler will do it automatically for you. But if you want the opposite, specify the required type in parentheses following the assignment operator. Keep in mind, the <code class="language-java">boolean</code> type cannot be cast to another type and vice versa.</p>
</div>
